<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Panda Adventure - Retro Runner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --pixel-size: 4px;
            --bg-color: #87CEEB;
            --ui-panel: rgba(0, 0, 0, 0.7);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            font-family: 'VT323', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 16 / 9;
            background-color: var(--bg-color);
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
            transition: background-color 2s ease;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10;
            text-align: center;
        }

        h1 { font-size: 64px; margin-bottom: 10px; text-shadow: 4px 4px #e74c3c; }
        p { font-size: 24px; margin-bottom: 20px; }

        .btn {
            padding: 15px 40px;
            font-size: 32px;
            background: #2ecc71;
            color: white;
            border: none;
            border-bottom: 6px solid #27ae60;
            cursor: pointer;
            font-family: 'VT323', monospace;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            border-bottom-width: 2px;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
            font-size: 28px;
        }

        .hearts { color: #ff4757; font-size: 32px; text-shadow: 2px 2px #000; }
        .score-box { text-shadow: 2px 2px #000; text-align: right; }
        .stage-box { text-shadow: 2px 2px #000; color: #f1c40f; }

        /* Mobile Controls */
        #controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 40px;
            padding: 0 20px;
            z-index: 15;
        }

        .ctrl-btn {
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.2);
            border: 4px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            color: white;
            backdrop-filter: blur(5px);
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .ctrl-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.9);
        }

        .hidden { display: none !important; }

        #volume-control {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 20;
            background: var(--ui-panel);
            padding: 5px 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0.5;
        }

        #shake-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .shaking {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="shake-layer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="hearts" id="heart-display">â™¥â™¥â™¥</div>
        <div class="stage-box">STAGE: <span id="current-stage">1</span></div>
        <div class="score-box">
            SCORE: <span id="current-score">0</span><br>
            HIGH: <span id="high-score">0</span>
        </div>
    </div>

    <!-- UI Panels -->
    <div id="start-screen" class="overlay">
        <h1>BABY PANDA</h1>
        <p>Game Build BY - OMDEEP LARIYA Ji</p>
        <button class="btn" id="start-btn">START GAME</button>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <h1 style="color: #ff4757;">GAME OVER</h1>
        <p>You reached Stage <span id="final-stage">1</span> with <span id="final-score">0</span> points!</p>
        <button class="btn" id="restart-btn">RETRY</button>
    </div>

    <div id="pause-btn-ui" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10;">
        <button id="pause-toggle" style="background:none; border:none; color:white; font-family: 'VT323'; cursor:pointer; font-size: 20px;">[PAUSE]</button>
    </div>

    <!-- Mobile Controls -->
    <div id="controls" style="justify-content: space-between;">
        <div class="ctrl-btn" id="jump-btn" style="position: fixed; bottom: 20px; left: 20px;">JUMP</div>
        <div class="ctrl-btn" id="djump-btn" style="position: fixed; bottom: 20px; right: 20px;">DBL JUMP</div>
    </div>

    <div id="volume-control">
        <span>VOL</span>
        <input type="range" id="vol-slider" min="0" max="100" value="50">
    </div>
</div>

<script>
/**
 * AUDIO ENGINE
 */
class AudioEngine {
    constructor() {
        this.ctx = null;
        this.masterVolume = 0.5;
        this.bgMusicNode = null;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    }

    setVolume(val) {
        this.masterVolume = val / 100;
        if (this.bgMusicNode) this.bgMusicNode.gain.value = this.masterVolume * 0.3;
    }

    playJump() { this.beep(400, 600, 0.1, 'triangle'); }
    playEat() { this.beep(800, 1200, 0.05, 'sine'); }
    playHit() { this.beep(200, 50, 0.2, 'sawtooth'); }
    playWin() { this.beep(440, 880, 0.3, 'square'); }
    playGameOver() { this.beep(300, 100, 0.5, 'square'); }
    playSplash() { this.beep(150, 80, 0.3, 'sine'); }

    beep(startFreq, endFreq, duration, type) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(startFreq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(endFreq, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(this.masterVolume, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playMusic() {
        if (this.bgMusicNode) return; // Prevent multiple instances of the music

        const audio = new Audio('panda/assets/bgmusic.mp3'); // Replace with your music file path
        audio.loop = true; // Enable looping
        audio.volume = this.masterVolume * 0.5; // Set volume
        audio.play();

        this.bgMusicNode = audio; // Store the audio instance
    }

    playLoseLifeSound() {
        const audio = new Audio('assets/lose-life.mp3'); // Path to lose life sound
        audio.volume = this.masterVolume * 0.5; // Adjust volume
        audio.play();
    }

    playJumpSound() {
        const audio = new Audio('assets/jump.mp3'); // Path to jump sound
        audio.volume = this.masterVolume * 0.5; // Adjust volume
        audio.play();
    }

    playEatCarrotSound() {
        const audio = new Audio('assets/eat-carrot.mp3'); // Path to eat carrot sound
        audio.volume = this.masterVolume * 0.5; // Adjust volume
        audio.play();
    }
}

/**
 * ASSET GENERATOR
 */
const Assets = {
    panda: null,
    snake: null,
    crab: null,
    bird: null,
    carrot: null,
    turtle: null,
    tree: null,

    init() {
        this.panda = this.createSVGIcon('ðŸ¼', 64);
        this.snake = this.createSVGIcon('ðŸ', 48);
        this.crab = this.createSVGIcon('ðŸ¦€', 48);
        this.bird = this.createSVGIcon('ðŸ¦', 48);
        this.carrot = this.createSVGIcon('ðŸ¥•', 40);
        this.turtle = this.createSVGIcon('ðŸ¢', 64);
        this.tree = this.createSVGIcon('ðŸŒ³', 80);
    },

    createSVGIcon(emoji, size) {
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.font = `${size * 0.8}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(emoji, size/2, size/2);
        return canvas;
    }
};

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const audio = new AudioEngine();

// Constants
const GRAVITY = 0.6;
const GROUND_Y = 350;
const WIDTH = 800;
const HEIGHT = 450;
canvas.width = WIDTH;
canvas.height = HEIGHT;

// Game State
let gameState = 'START';
let score = 0;
let highScore = localStorage.getItem('panda_highscore') || 0;
let lives = 3;
let stage = 1;
let stageProgress = 0;
let stageTarget = 3000;
let gameSpeed = 5;
let frameCount = 0;

// Environment Themes
const THEMES = [
    { sky: "#87CEEB", ground: "#228B22", mountain: "#5DADE2", water: "#3498DB" },
    { sky: "#FF7F50", ground: "#8B4513", mountain: "#E67E22", water: "#2980B9" },
    { sky: "#2C3E50", ground: "#1B4F72", mountain: "#17202A", water: "#154360" },
    { sky: "#4B0082", ground: "#2D1B33", mountain: "#1A0633", water: "#1F1A38" }
];

// Entities
let player;
let enemies = [];
let collectibles = [];
let platforms = [];
let scenery = []; // Trees and bushes
let hazards = []; // Water pits
let floaters = [];
let turtleObj = null;

class Player {
    constructor() {
        this.width = 50;
        this.height = 50;
        this.x = 80;
        this.y = GROUND_Y - this.height;
        this.vy = 0;
        this.jumpPower = -12;
        this.jumps = 0;
        this.isHurt = 0;
        this.onPlatform = false;
    }

    update() {
        this.vy += GRAVITY;
        this.y += this.vy;

        let groundLevel = GROUND_Y - this.height;
        this.onPlatform = false;

        // Check if player is over water and not on a bridge/platform
        let overWater = false;
        hazards.forEach(h => {
            if (this.x + this.width * 0.8 > h.x && this.x + this.width * 0.2 < h.x + h.w) {
                overWater = true;
            }
        });

        // Check platform and bridge collisions
        platforms.forEach(p => {
            if (this.vy >= 0 && 
                this.x + this.width > p.x && 
                this.x < p.x + p.w && 
                this.y + this.height >= p.y && 
                this.y + this.height <= p.y + 25) {
                this.y = p.y - this.height;
                this.vy = 0;
                this.jumps = 0;
                this.onPlatform = true;
                overWater = false; // Bridge protects from water
            }
        });

        if (!this.onPlatform) {
            if (overWater) {
                if (this.y > HEIGHT) {
                    this.respawn();
                }
            } else if (this.y > groundLevel) {
                this.y = groundLevel;
                this.vy = 0;
                this.jumps = 0;
            }
        }

        if (this.isHurt > 0) this.isHurt--;
    }

    respawn() {
        lives--;
        this.isHurt = 60;
        this.y = 0;
        this.vy = 0;
        this.x = 80;
        audio.playSplash();
        updateHUD();
        if (lives <= 0) gameOver();
    }

    jump() {
        if (this.jumps < 2) {
            this.vy = this.jumpPower;
            this.jumps++;
            audio.playJump();
        }
    }

    draw() {
        ctx.save();
        if (this.isHurt % 4 > 1) ctx.globalAlpha = 0.5;
        const tilt = this.vy * 0.02;
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        ctx.rotate(tilt);
        ctx.drawImage(Assets.panda, -this.width/2, -this.height/2, this.width, this.height);
        ctx.restore();
    }
}

class Platform {
    constructor(x, y, w, type = 'floating') {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = 20;
        this.type = type; // 'floating' or 'bridge'
    }
    update() { this.x -= gameSpeed; }
    draw() {
        if (this.type === 'bridge') {
            // Draw bridge planks
            ctx.fillStyle = "#5D4037";
            const plankW = 15;
            for(let bx = 0; bx < this.w; bx += plankW + 2) {
                ctx.fillRect(this.x + bx, this.y, plankW, this.h);
            }
            // Bridge rails
            ctx.fillStyle = "#3E2723";
            ctx.fillRect(this.x, this.y - 5, this.w, 5);
        } else {
            const theme = THEMES[(stage - 1) % THEMES.length];
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.fillStyle = theme.ground;
            ctx.fillRect(this.x, this.y, this.w, 6);
        }
    }
}

class Hazard {
    constructor(x, w) {
        this.x = x;
        this.w = w;
    }
    update() { this.x -= gameSpeed; }
    draw() {
        const theme = THEMES[(stage - 1) % THEMES.length];
        ctx.fillStyle = theme.water;
        ctx.fillRect(this.x, GROUND_Y, this.w, HEIGHT - GROUND_Y);
        // Waves
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 2;
        for(let i=0; i<3; i++) {
            const waveX = (this.x + (frameCount + i*30) % 60);
            ctx.beginPath();
            ctx.moveTo(this.x, GROUND_Y + 10 + i*15);
            ctx.lineTo(this.x + this.w, GROUND_Y + 10 + i*15);
            ctx.stroke();
        }
    }
}

class Scenery {
    constructor(x, type) {
        this.x = x;
        this.type = type;
        this.scale = 0.8 + Math.random() * 0.5;
    }
    update() { this.x -= gameSpeed * 0.8; }
    draw() {
        ctx.drawImage(Assets.tree, this.x, GROUND_Y - 70 * this.scale, 80 * this.scale, 80 * this.scale);
    }
}

class Enemy {
    constructor(type) {
        this.type = type;
        this.width = 40;
        this.height = 40;
        this.x = WIDTH + 100;
        this.speed = gameSpeed + (Math.random() * 2);
        
        if (type === 'bird') {
            this.y = 100 + Math.random() * 100;
            this.img = Assets.bird;
        } else {
            this.y = GROUND_Y - this.height;
            this.img = type === 'snake' ? Assets.snake : Assets.crab;
        }
    }
    update() {
        this.x -= this.speed;
        if (this.type === 'bird') this.y += Math.sin(frameCount * 0.1) * 2;
    }
    draw() { ctx.drawImage(this.img, this.x, this.y, this.width, this.height); }
}

function initGame(resetScore = true) {
    player = new Player();
    enemies = [];
    collectibles = [];
    platforms = [];
    scenery = [];
    hazards = [];
    floaters = [];
    turtleObj = null;
    stageProgress = 0;
    if(resetScore) {
        score = 0;
        lives = 3;
        stage = 1;
        gameSpeed = 5;
    }
    updateHUD();
}

function updateHUD() {
    document.getElementById('current-score').innerText = score;
    document.getElementById('high-score').innerText = highScore;
    document.getElementById('current-stage').innerText = stage;
    document.getElementById('heart-display').innerText = "â™¥".repeat(lives);
}

function checkCollision(a, b) {
    return a.x < b.x + (b.width || b.w) - 5 &&
           a.x + a.width - 5 > b.x &&
           a.y < b.y + (b.height || b.h) - 5 &&
           a.y + a.height - 5 > b.y;
}

function gameLoop() {
    if (gameState !== 'PLAYING') return requestAnimationFrame(gameLoop);

    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    frameCount++;
    stageProgress += gameSpeed;

    drawBackground();

    // Spawn Scenery
    if (frameCount % 60 === 0) {
        scenery.push(new Scenery(WIDTH + 100, 'tree'));
    }

    // Spawn Water and Bridges
    if (frameCount % 240 === 0 && stageProgress < stageTarget - 1000) {
        const waterW = 150 + Math.random() * 100;
        hazards.push(new Hazard(WIDTH, waterW));
        // Small chance of a bridge over water
        if (Math.random() > 0.4) {
            platforms.push(new Platform(WIDTH - 20, GROUND_Y - 10, waterW + 40, 'bridge'));
        }
    }

    // Spawn Floating Platforms
    if (frameCount % 180 === 0 && stageProgress < stageTarget - 800) {
        platforms.push(new Platform(WIDTH, 180 + Math.random() * 60, 120 + Math.random() * 80));
    }

    // Spawn Enemies
    if (frameCount % Math.max(30, 100 - (stage * 5)) === 0 && stageProgress < stageTarget - 500) {
        const r = Math.random();
        if (r < 0.3) enemies.push(new Enemy('snake'));
        else if (r < 0.6) enemies.push(new Enemy('crab'));
        else enemies.push(new Enemy('bird'));
    }

    // Spawn Collectibles
    if (frameCount % 120 === 0) collectibles.push({
        x: WIDTH + 50,
        y: 120 + Math.random() * 180,
        width: 30, height: 30
    });

    // Handle Turtle Finish
    if (stageProgress >= stageTarget && !turtleObj) {
        turtleObj = { x: WIDTH + 100, y: GROUND_Y - 60, width: 60, height: 60 };
    }

    // Update Entities
    scenery.forEach((s, i) => { s.update(); s.draw(); if (s.x < -200) scenery.splice(i, 1); });
    hazards.forEach((h, i) => { h.update(); h.draw(); if (h.x < -h.w) hazards.splice(i, 1); });
    platforms.forEach((p, i) => { p.update(); p.draw(); if (p.x < -p.w) platforms.splice(i, 1); });

    // Player
    player.update();
    player.draw();

    // Enemies
    enemies.forEach((e, i) => {
        e.update();
        e.draw();
        if (checkCollision(player, e) && player.isHurt === 0) {
            lives--;
            player.isHurt = 60;
            audio.playHit();
            updateHUD();
            if (lives <= 0) gameOver();
        }
        if (e.x < -100) enemies.splice(i, 1);
    });

    // Collectibles
    collectibles.forEach((c, i) => {
        c.x -= gameSpeed;
        ctx.drawImage(Assets.carrot, c.x, c.y, c.width, c.height);
        if (checkCollision(player, c)) {
            score += 15;
            audio.playEat();
            floaters.push({x: player.x, y: player.y, text: "+15", alpha: 1});
            updateHUD();
            collectibles.splice(i, 1);
        }
        if (c.x < -50) collectibles.splice(i, 1);
    });

    // Turtle
    if (turtleObj) {
        turtleObj.x -= gameSpeed;
        ctx.drawImage(Assets.turtle, turtleObj.x, turtleObj.y, turtleObj.width, turtleObj.height);
        if (checkCollision(player, turtleObj)) nextStage();
    }

    // Floaters
    floaters.forEach((f, i) => {
        f.y -= 2; f.alpha -= 0.02;
        ctx.fillStyle = `rgba(255, 255, 255, ${f.alpha})`;
        ctx.font = "24px VT323";
        ctx.fillText(f.text, f.x, f.y);
        if (f.alpha <= 0) floaters.splice(i, 1);
    });

    requestAnimationFrame(gameLoop);
}

function nextStage() {
    stage++;
    gameSpeed += 0.8;
    stageTarget += 1000;
    audio.playWin();
    floaters.push({x: WIDTH/2, y: HEIGHT/2, text: "STAGE CLEAR!", alpha: 2});
    enemies = [];
    platforms = [];
    hazards = [];
    turtleObj = null;
    stageProgress = 0;
    updateHUD();
}

function drawBackground() {
    const themeIdx = (stage - 1) % THEMES.length;
    const currentTheme = THEMES[themeIdx];
    const cycle = (frameCount % 2400) / 2400;
    
    ctx.fillStyle = currentTheme.sky;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    ctx.save();
    ctx.translate(WIDTH/2, GROUND_Y + 150);
    ctx.rotate(cycle * Math.PI * 2);
    ctx.fillStyle = "#F1C40F"; // Sun
    ctx.beginPath(); ctx.arc(0, -400, 45, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = "#ECF0F1"; // Moon
    ctx.beginPath(); ctx.arc(0, 400, 35, 0, Math.PI * 2); ctx.fill();
    ctx.restore();

    ctx.fillStyle = currentTheme.mountain;
    for(let i=0; i<6; i++) {
        const x = ((i * 250) - (frameCount * 0.4)) % 1500;
        ctx.beginPath();
        ctx.moveTo(x - 120, GROUND_Y);
        ctx.lineTo(x + 60, 150 + (i % 3 * 30));
        ctx.lineTo(x + 240, GROUND_Y);
        ctx.fill();
    }

    ctx.fillStyle = currentTheme.ground;
    ctx.fillRect(0, GROUND_Y, WIDTH, HEIGHT - GROUND_Y);
    
    ctx.fillStyle = "rgba(0,0,0,0.15)";
    for(let i=0; i<25; i++) {
        const x = (i * 40 - (frameCount * gameSpeed) % 40);
        ctx.fillRect(x, GROUND_Y + 8, 12, 4);
    }
}

function gameOver() {
    gameState = 'GAMEOVER';
    audio.playGameOver();
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('panda_highscore', highScore);
    }
    document.getElementById('final-score').innerText = score;
    document.getElementById('final-stage').innerText = stage;
    document.getElementById('game-over-screen').classList.remove('hidden');
}

function startGame() {
    audio.init();
    audio.playMusic();
    initGame();
    gameState = 'PLAYING';
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
}

// Controls
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('pause-toggle').addEventListener('click', () => {
    if (gameState === 'PLAYING') gameState = 'PAUSED';
    else if (gameState === 'PAUSED') gameState = 'PLAYING';
    document.getElementById('pause-toggle').innerText = gameState === 'PAUSED' ? '[RESUME]' : '[PAUSE]';
});

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); player.jump(); }
});

const touchJump = (e) => { 
    e.preventDefault(); 
    if(gameState === 'PLAYING') player.jump(); 
    else if(gameState==='START') startGame(); 
};
document.getElementById('jump-btn').addEventListener('touchstart', touchJump);
document.getElementById('djump-btn').addEventListener('touchstart', touchJump);
document.getElementById('jump-btn').addEventListener('mousedown', touchJump);
document.getElementById('djump-btn').addEventListener('mousedown', touchJump);

document.getElementById('vol-slider').addEventListener('input', (e) => audio.setVolume(e.target.value));

window.onload = () => {
    Assets.init();
    initGame();
    requestAnimationFrame(gameLoop);
};
</script>
</body>
</html>

